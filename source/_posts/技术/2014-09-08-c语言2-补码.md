---
title: c语言2-补码
date: 2014/09/08 08:00:00
categories: 技术
toc: True
tags: c语言
---
## 流程图简要
椭圆：开始/结束
平行四边行：输入
陵行：判断
矩行：操作


## 类型介绍
备注：为什么正数数值范围都是2的多少次方减1：因为由于补码规则可知，同一个补码可能表示一个正数也可能表示一个负数，所以为了避免这种歧义，就规定了补码的最高位为符号位，这样以来一个补码就对应一个正数了，但是+0和-0都是0
          比如：八位二进制的正数最大值是 1111 1111 = 2^8-1 (数列) 0111 1111 2^7-1


## 命名规范

## 物理基础
1. cpu在运作时，读取内存数据，首先要指定存储单元的地址，就是要确定读写哪段数据。即要明确三件事
a. 存储单元地址（地址信息）
b. 器件的选择，读or写（控制信息）
c. 读写的数据（数据信息）
2. 地址总线：cpu通过地址总线告诉内存我们需要操作指定的空间 
3. 数据总线：cpu 通过数据总线实现与内存的数据交互
4. 控制总线：cpu对其他硬件设备发出需要对其进行的操作（读/写）的命令

![cpu对内存的读写操作详解](cpu对内存的读写操作详解.png)



## 补码
概念：在计算机系统中，数值一律用补码来表述或者存储，原因在于，可以将符号和数值域统一处理；同时加法和减法也可以统一处理此外，补码和原码的运算过程是相同的，不需要额外的硬件电路

备注：
1. 补码都是二进制，以及计算机下面的所有储存地址还是数据都是补码，为什么我们看到的不同，是因为我们的ide或者cpu进行过特殊处理，因为如果全部用二进制显示会得到一串我们很难分析的字符
2. 原码都是十进制，所以将补码转化为源码其实就是将二进制转化为十进制
3. 正数的源码就是他本身，负数的源码是”求反加一“，负数的源码求反码也是如此
4. 补码解决了三件事情：
a. 解决了正负零的问题
b. 解决了符号参加运算的问题
c. 实现了减法，乘法，除法都变加法的问题

![补码求原](补码求原.png)

## ASCII码
ascii码的显示效果就是cpu操作显卡的结果
例如:97是a的asscii码，转换成ascii码的时候需要先将97转换为补码(二进制)


## 16进制
我们保存16进制数据时其实是直接将16进制的数据保存到了内存中，不像十进制会进行补码操作，%x因为输出的是16进制，所以每次输出都要满4个字节，如果前面的数据为0他是省略的，但是并不表示他是没有的，如果前面位数不够，会根据符号位来进行补位操作，如果符号位是0就把前面的都补0知道补满为止
例子： short类型  0x8756   用%x输出是ffff8756
理解：1：首先我们需要确认数据的类型，因为数据的类型是short，（如果是int就没必要补位了，因为肯定是正数，最高位（符号位）是第32位，是0，省略了） ，所以我们取到short的最高的符号位（第16位/2个字节），就是8的补码的最高位，1000，所以前面是1那么前面全部补1，知道补满32位 然后每四个1就是一个f（因为是16进制输出），所以就得到
1111 1111 1111  1111 所以就得到ffff8756

## 总结
根据十六进制来保存数据时，其实是直接将16进制保存到内存中，不像10进制会进行补码操作
补位补位步骤:
1. 确定类型
2. 根据类型确定最高位（符号位）
3. 根据符号位来进行补位，知道补满（根据我们是要输出16进制还是8进制还是10进制来判断）为止（如果是1则补1，如果是0则补0）