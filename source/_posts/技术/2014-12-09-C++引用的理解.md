---
title: C++引用的理解
date: 2014/12/09 08:00:00
categories: 技术
toc: True
tags: c++
---
## 定义
引用引入了对象的一个同义词.定义引用的表示方法与定义指针相似,只是用&代替了*.引用（reference）是c++对c语言的重要扩充.引用就是某
一变量（目标）的一个别名,对引用的操作与对变量直接操作完全一样.其格式为:类型 &引用变量名 = 已定义过的变量名.


## 特点
一个变量可取多个别名.

引用必须初始化.

引用只能在初始化的时候引用一次 ,不能更改为转而引用其他变量.



## code
### 基础引用

```c++
void TestReference1 ()  
{  
     int a = 1;  
     int& b = a;  
  
     cout<<"a:address->" <<&a<< endl;  
     cout<<"b:address->" <<&b<< endl;  
  
     a = 2;  
     b = 3;  
     int& c = b;// 引用一个引用变量,别名的别名  
     c = 4;  
}
```

### const引用

```c++
void TestReference2 ()  
{  
     int d1 = 4;  
     const int & d2 = d1;  
     d1 = 5;//d1改变,d2的值也会改变.  
     //d2 = 6;//不能给常量（不能被修改的量）赋值.  
  
     const int d3 = 1;  
     const int & d4 = d3;  
     //int&d5 = d3;  
     const int & d6 = 5;//常量具有常性,只有常引用可以引用常量  
  
     double d7 = 1.1;  
     //int& d8 = d7;//d7是double类型,d8是int,d7赋值给 d8时要生成一个临时变量  
                   //也就是说d8引用的是这个带有常性的临时变量,所以不能赋值.  
     const int& d9 = d7;  
}  
```



## 引用作参数
```c++
1.【值传递】如果形参为非引用的传值方式,则生成局部临时变量接收实参的值  
void Swap (int left, int right) //值传递的方式无法实现交换,因为传参时对于参数left和right拷贝一临时副本,交换的是副本值,因为其是临时变量函数退出,变量销 {                                //毁,并不会影响外部left和right的值.  
     int temp = left;  
     left = right ;  
     right = temp ;  
}  
  
2.【引用传递】如果形参为引用类型,则形参是实参的别名.  
void Swap (int& left, int& right)//使用引用的话,不做临时拷贝,&的使用说明此处只是原参数的另一个名字而已,所以修改时直接在原参数的基础上修改变量值.  
{  
     int temp = left;  
     right = left ;  
     left = temp ;  
}  
  
3.【指针传递】  
void Swap (int* pLeft, int* pRight)//传入的是地址,因为地址是唯一的,所以指针通过地址的访问进而可修改其内容.  
{  
     int temp = *pLeft;  
     *pLeft = *pRight;  
     *pRight = temp;  
}  
```

***

## 注意
不要返回一个临时变量的引用.
如果返回对象出了当前函数的作用域依旧存在,则最好使用引用返回,因为这样更高效.

### 引用和指针的区别和联系（笔试热点）
引用必须指向有效的变量,指针可以为空.
sizeof指针对象和引用对象的意义不一样.sizeof引用得到的是所指向的变量的大小,而sizeof指针是对象地址的大小.
指针和引用自增(++)自减(--)意义不一样.
相对而言,引用比指针更安全.



## 引用和指针的区别和联系
### 不同点
指针是一个实体,而引用仅是个别名;
引用使用时无需解引用(*),指针需要解引用;
引用只能在定义时被初始化一次,之后不可变;指针可变;
引用没有 const,指针有 const;const修饰的指针不可变;
引用不能为空,指针可以为空;
"sizeof 引用"得到的是所指向的变量(对象)的大小,而"sizeof 指针"得到的是指针本身(所指向的变量或对象的地址)的大小;
指针和引用的自增(++)运算意义不一样;
从内存分配上看:程序为指针变量分配内存区域,而引用不需要分配内存区域.

### 相同点
两者都是地址的概念,指针指向一块儿内存,其内容为所指内存的地址;引用是某块儿内存的别名



## const在C和C++中的含义(笔试热点)
### C中的const,功能比较单一,较容易理解
作用:被修饰的内容不可更改.
使用场合:修饰变量,函数参数,返回值等.（c++中应用场合要丰富的多）
特点: 是运行时const,因此不能取代#define用于成为数组长度等需要编译时常量的情况.同时因为是运行时const,可以只定义而不初始化,而在运行时初始化.如 const int iConst;. 另外,在c中,const变量默认是外部链接,因此在不同的编译单元中如果有同名const变量,会引发命名冲突,编译时报错.

### c++中的const
#### 非类成员const
const变量默认是内部连接的,因此在不同的编译单元中可以有同名的const 变量定义.
编译时常量,因此可以像#define一样使用,而且因为上面一点,可以在头文件中定义const变量,包含的不同的cpp文件（编译
单元）中使用而不引起命名冲突.
编译器默认不为const变量分配内存,除非:1. 使用 extern 申明, 2:程序中有引用const 变量的地址.
c++中临时对象/内置变量默认具有const属性.

#### 类中的const
与c语言中的const一样,只是运行时常量,不能作为数组维数使用,即不能取代#define.在类中使用下面两种方式取代#define: 1:static const... 
enum{....}//enum 不占存储空间.
类中的const 变量占用存储空间.
类中的const成员变量需要在构造函数初始化列表中初始化.
const 对象:在该对象生命周期内,必须保证没有任何成员变量被改变.const对象只能调用const成员函数.
const成员函数: void fun() const ... 不仅能被const对象调用,也能被非const对象调用,因此,如果确认一个任何成员函数不改
变任何成员变量,应该习惯性将该函数定义成const类型.
如果一个对象被定义成const,那么该const对象"可能"会被放入到ROM当中,这在嵌入式开发当中有时非常重要.


***
> 本文引用自：http://blog.csdn.net/Xiao__Tian__/article/details/51814617