---
title: c语言7-指针
date: 2014/09/24 08:00:00
categories: 技术
toc: True
tags: c语言
---
## 内存
我们计算机的所有内存都是线性的，不管是一维数组还是二维数组在内存中都是线性的，内存线性是物理基础（不要问我）

机器的不同，导致指针类型的大小不同，32位机的指针类型是4个字节，64位机的指针大小是8个字节，而位数的多少又影响到地址总线的宽度，导致最大支持的内存大小（内存条），所以32位机支持的最大的内存条是4g，并且4g有一部分被其他硬件占用，所以剩3g多来给用户使用，地址总线越宽，同一时间传输的地址数据就越多，从而达到同一时间可以让跟多的软件来访问内存，起到同一时间可以运行更多的软件

## 十六进制的解释
一个十六进制位数表示4个二进制位数，我们为一个变量赋一个16进制数和一个10进制数的表达方式是一样的，只不过打出的数据不同，
十六进制的读操作：
因为我们的电脑是4个二进制对应一位16进制的数，所以我们内存里的一个存储单元可以存储两位16进制的数，并且我们根据指针读数据都是从低位向高位读取，并且每个变量保存的都是首地址，所以:
```c
inta=0x0355;
int*a1=(int*)&a;//355
char*a2=(char*)&a;//55  拿到低位地址 根据类型（寻址能力）向上找到数据后用数据总线返回cpu
short*a3=(short*)&a;//355
```
0会被忽略

## 从大类型转换为小类型数据截取的解释
我们的数据在内存条中都是线性存储的并且占时的内存大小是从大到小的  但是我们此时的首地址是不变的，只是寻址能能力变化了  例如  int  a=0x12345678 char p=(char)a   printf("p=%x"); p=78

## 指针和地址的区别
指针是一个有类型的地址，所以我们可以根据地址来设置地址偏移来获取数据
备注:我们变量保存的都是首地址（当前数据空间最小的地址），然后根据数据类型来去从首地址拿指定个数的空间数据（因为现在我首地址和类型（空间个数）和每个空间的大小（8位）都确定了 所以我们可以按照规律取出数据）

*：根据地址取内容  前提要有地址 
&：根据变量取地址，如果对象是数组的话我们根据他取到的是数组的整体

## 自定义地址(危险)
直接为一个指针变量赋一个我们自己写的值的画很危险，因为我们随机写的地址可能是系统内核占用的，所以可能影响到系统，所以我们申请内存一般都是需要系统帮我申请，而不是自己随机写地址，一般4g的内存的话 0~3g为用户内存，3g~4g为系统内存，所以3g~4g的地址我们是不能申请的

## 同类型数据加减的问题
同类型相减等于相隔空格数，基本类型除外

## 数组和指针的关系
数组名是个常量  不能修改 不能进行加减计算
*p++ 先算++ 再去值
一级数组和指针的关系：a+1表示

## 数组的首地址和数组元素的首地址之间的关系
"指针"加数值，加的是该对象对应的数组的步长
数组的整体和元素性：对数组加上&就是表述数组的整体性
```c
intarr[3][4]={1,2,3,4,10,20,30,40,100,200,300,400}; //T arr[3]
printf("arr=%p\n",arr+1);//arr的数组的步长为int[4]所以加的是int[4]的字节大小
printf("&arr=%p\n",&arr+1);//表示数组的整体，所以步长为整个数组，所以加的是整个数组的长度
printf("&arr[0]=%p\n",arr[0]+1);//arr[0]这里不是表示地址 而是取值 不考虑
printf("&arr[0]=%p\n",&arr[0]+1);//&arr的数组的步长为int[4]，所以加的是int[4]的字节大小
intarr[5]={10,20,30,40,50}; 
printf("arr[0]=%p\n",arr[0]);//这里是直接取值  不是指针 不考虑 直接加一
printf("&arr[0]=%p\n",&arr[0]);//&arr的数组的步长为int所以加上int类型大小
printf("arr[0]+1=%p\n",arr[0]+1);//
这里是直接取值  不是指针 不考虑 直接加一
printf("&arr[0]+1=%p\n",&arr[0]+1);//
&arr的数组的步长为int所以加上int类型大小
printf("&arr+1=%p\n",&arr+1);//&考虑的是整体性 直接加上int[5]的类型大小
printf("&arr[0]=%p\n",&arr[0]);//&arr[0]的数组的步长为int 所以直接加int
printf("&arr+1=%p\n",&arr+1);//整体  直接加int[4]
```

## 指针类型变量的二义性
```c
int * p1=&a;   //p1：表示的是a的地址；&p1表示的是p1变量本身的地址
```

## 根据指针偏移遍历集合的方法
```c
int arr[5]={10,20,30,40,50};
for(inti=0;i<5;i++)
printf("%d\n",arr[i]);
printf("--------------\n");
for(inti=0;i<5;i++)
printf("%d\n",i[arr]);
printf("--------------\n");
for(inti=0;i<5;i++)
printf("%d\n",*(arr+i));//arr+iarr的类型为int所以偏移int的i位
printf("--------------\n");
int*p=&arr;
for(inti=0;i<5;i++)
printf("%d\n",*p++);//先算p++结果为*p后++
```
a[i]=*(a+i)

*也起到降级别的能力

![指针偏移法](指针偏移法.png)